# poor-cli Neovim Extension Implementation TODO
# Each task is a single, actionable item with enough context for any AI agent to complete it independently
# Status: [ ] = pending, [x] = done, [~] = in progress
# Created: 2026-01-31

# ============================================================================
# PHASE 1: CORE LIBRARY EXTRACTION (poor_cli/core.py)
# Goal: Create a headless engine that can be used by CLI, Neovim, VSCode, etc.
# ============================================================================

[x] 1.1 Create file poor_cli/core.py with class PoorCLICore that has __init__ accepting optional config_path parameter and initializing empty provider, tool_registry, history, checkpoint_manager, and config attributes
[x] 1.2 In poor_cli/core.py add async method initialize(self, provider_name: str = None, model_name: str = None, api_key: str = None) that loads config from ConfigManager, creates provider via ProviderFactory.create(), initializes ToolRegistryAsync, and sets up system instruction - extract logic from repl_async.py lines 114-298
[x] 1.3 In poor_cli/core.py add async method send_message(self, message: str, context_files: List[str] = None) -> AsyncIterator[str] that yields streaming text chunks from provider.send_message_stream(), handling function calls internally - extract logic from repl_async.py lines 1417-1502
[x] 1.4 In poor_cli/core.py add async method send_message_sync(self, message: str, context_files: List[str] = None) -> str that returns complete response text without streaming, handling function calls internally - extract logic from repl_async.py lines 1504-1563
[x] 1.5 In poor_cli/core.py add async method execute_tool(self, tool_name: str, arguments: Dict[str, Any]) -> str that wraps tool_registry.execute_tool and returns result string
[x] 1.6 In poor_cli/core.py add async method inline_complete(self, code_before: str, code_after: str, instruction: str, file_path: str, language: str) -> AsyncIterator[str] that creates a FIM (fill-in-middle) prompt asking the AI to generate code to insert between code_before and code_after based on instruction, yields streaming completion chunks
[x] 1.7 In poor_cli/core.py add method build_fim_prompt(self, code_before: str, code_after: str, instruction: str, file_path: str, language: str) -> str that constructs a prompt like "Complete the code between <|fim_prefix|> and <|fim_suffix|> markers. File: {file_path}, Language: {language}. Instruction: {instruction}\n<|fim_prefix|>{code_before}<|fim_cursor|><|fim_suffix|>{code_after}" 
[x] 1.8 In poor_cli/core.py add async method handle_function_calls(self, response: ProviderResponse, require_permission: bool = True) -> Tuple[bool, List[Dict]] that processes function calls from response, optionally requiring permission callback, returns (success, results) - extract logic from repl_async.py lines 1662-1749
[x] 1.9 In poor_cli/core.py add property permission_callback that can be set to a callable(tool_name: str, tool_args: dict) -> Awaitable[bool] for requesting user permission on file operations
[x] 1.10 In poor_cli/core.py add async method apply_edit(self, file_path: str, old_text: str, new_text: str) -> str that uses tool_registry.edit_file to apply a code edit and returns success/error message
[x] 1.11 In poor_cli/core.py add async method read_file(self, file_path: str, start_line: int = None, end_line: int = None) -> str that uses tool_registry.read_file and returns file contents
[x] 1.12 In poor_cli/core.py add async method write_file(self, file_path: str, content: str) -> str that uses tool_registry.write_file and returns success message
[x] 1.13 In poor_cli/core.py add method get_available_tools(self) -> List[Dict] that returns tool_registry.get_tool_declarations()
[x] 1.14 In poor_cli/core.py add method get_provider_info(self) -> Dict with keys 'name', 'model', 'capabilities' from current provider
[x] 1.15 In poor_cli/core.py add async method clear_history(self) that calls provider.clear_history() and resets conversation state
[x] 1.16 In poor_cli/core.py add method get_history(self) -> List[Dict] that returns provider.get_history() in normalized format with 'role' and 'content' keys
[x] 1.17 In poor_cli/core.py add async method switch_provider(self, provider_name: str, model_name: str = None) that switches to a new provider while preserving configuration
[x] 1.18 In poor_cli/core.py add method set_system_instruction(self, instruction: str) that updates the system instruction for the current provider
[x] 1.19 In poor_cli/core.py add async method create_checkpoint(self, file_paths: List[str], description: str) -> str that uses checkpoint_manager to create checkpoint and returns checkpoint_id
[x] 1.20 In poor_cli/core.py add async method restore_checkpoint(self, checkpoint_id: str) -> bool that uses checkpoint_manager to restore and returns success status
[x] 1.21 Update poor_cli/__init__.py to export PoorCLICore class by adding "from .core import PoorCLICore" and adding "PoorCLICore" to __all__ list
[ ] 1.22 Refactor poor_cli/repl_async.py class PoorCLIAsync to use PoorCLICore internally - replace direct provider/tool calls with self.core.send_message(), self.core.execute_tool(), etc. to avoid code duplication
[ ] 1.23 Create file poor_cli/core_test.py with pytest async tests for PoorCLICore: test_initialize, test_send_message, test_inline_complete, test_execute_tool, test_switch_provider using mock provider

# ============================================================================
# PHASE 2: JSON-RPC SERVER INTERFACE (poor_cli/server.py)
# Goal: Create a server that Neovim/VSCode can communicate with via JSON-RPC
# ============================================================================

[x] 2.1 Create file poor_cli/server.py with imports: json, asyncio, sys, logging, and from poor_cli.core import PoorCLICore
[x] 2.2 In poor_cli/server.py create class JsonRpcMessage as dataclass with fields: jsonrpc (str, default "2.0"), id (Optional[int]), method (Optional[str]), params (Optional[Dict]), result (Optional[Any]), error (Optional[Dict])
[x] 2.3 In poor_cli/server.py create class JsonRpcError with class constants: PARSE_ERROR = -32700, INVALID_REQUEST = -32600, METHOD_NOT_FOUND = -32601, INVALID_PARAMS = -32602, INTERNAL_ERROR = -32603
[x] 2.4 In poor_cli/server.py create class PoorCLIServer with __init__(self) that initializes self.core = PoorCLICore(), self.handlers = {} dict mapping method names to handler functions, self.initialized = False, self.logger = logging.getLogger("poor-cli-server")
[x] 2.5 In poor_cli/server.py PoorCLIServer add method register_handlers(self) that populates self.handlers dict with: "initialize" -> self.handle_initialize, "shutdown" -> self.handle_shutdown, "textDocument/completion" -> self.handle_completion, "poor-cli/chat" -> self.handle_chat, "poor-cli/inlineComplete" -> self.handle_inline_complete, "poor-cli/applyEdit" -> self.handle_apply_edit, "poor-cli/readFile" -> self.handle_read_file, "poor-cli/executeCommand" -> self.handle_execute_command, "poor-cli/getTools" -> self.handle_get_tools, "poor-cli/switchProvider" -> self.handle_switch_provider
[x] 2.6 In poor_cli/server.py PoorCLIServer add async method handle_initialize(self, params: Dict) -> Dict that calls await self.core.initialize(params.get("provider"), params.get("model"), params.get("apiKey")), sets self.initialized = True, returns {"capabilities": {"completionProvider": True, "inlineCompletionProvider": True, "chatProvider": True}}
[x] 2.7 In poor_cli/server.py PoorCLIServer add async method handle_shutdown(self, params: Dict) -> None that cleans up resources and returns None
[x] 2.8 In poor_cli/server.py PoorCLIServer add async method handle_chat(self, params: Dict) -> Dict that expects params with "message" (str), optional "contextFiles" (List[str]), calls self.core.send_message_sync(), returns {"content": response_text, "role": "assistant"}
[x] 2.9 In poor_cli/server.py PoorCLIServer add async method handle_inline_complete(self, params: Dict) -> Dict that expects params with "codeBefore" (str), "codeAfter" (str), "instruction" (str), "filePath" (str), "language" (str), collects chunks from self.core.inline_complete() generator, returns {"completion": full_text, "isPartial": False}
[x] 2.10 In poor_cli/server.py PoorCLIServer add async method handle_apply_edit(self, params: Dict) -> Dict that expects params with "filePath" (str), "oldText" (str), "newText" (str), calls self.core.apply_edit(), returns {"success": True/False, "message": result}
[x] 2.11 In poor_cli/server.py PoorCLIServer add async method handle_read_file(self, params: Dict) -> Dict that expects params with "filePath" (str), optional "startLine" (int), "endLine" (int), calls self.core.read_file(), returns {"content": file_content}
[x] 2.12 In poor_cli/server.py PoorCLIServer add async method handle_execute_command(self, params: Dict) -> Dict that expects params with "command" (str), executes bash command via self.core.execute_tool("bash", {"command": cmd}), returns {"output": result, "exitCode": 0}
[x] 2.13 In poor_cli/server.py PoorCLIServer add async method handle_get_tools(self, params: Dict) -> Dict that returns {"tools": self.core.get_available_tools()}
[x] 2.14 In poor_cli/server.py PoorCLIServer add async method handle_switch_provider(self, params: Dict) -> Dict that expects params with "provider" (str), optional "model" (str), calls self.core.switch_provider(), returns {"success": True, "provider": new_provider_info}
[x] 2.15 In poor_cli/server.py PoorCLIServer add async method dispatch(self, message: JsonRpcMessage) -> JsonRpcMessage that looks up handler in self.handlers by message.method, calls handler with message.params, wraps result in JsonRpcMessage with same id, handles errors by returning JsonRpcMessage with error field
[x] 2.16 In poor_cli/server.py PoorCLIServer add async method read_message_stdio(self) -> Optional[JsonRpcMessage] that reads Content-Length header from stdin, reads that many bytes of JSON body, parses into JsonRpcMessage, returns None on EOF
[x] 2.17 In poor_cli/server.py PoorCLIServer add async method write_message_stdio(self, message: JsonRpcMessage) that serializes message to JSON, writes "Content-Length: {len}\r\n\r\n{json}" to stdout, flushes stdout
[x] 2.18 In poor_cli/server.py PoorCLIServer add async method run_stdio(self) that loops: reads message via read_message_stdio(), dispatches via dispatch(), writes response via write_message_stdio(), handles graceful shutdown on EOF or shutdown request
[x] 2.19 In poor_cli/server.py create class StreamingJsonRpcServer(PoorCLIServer) that overrides handle_chat and handle_inline_complete to yield partial results as JSON-RPC notifications with method "poor-cli/streamChunk" and params {"requestId": id, "chunk": text, "done": bool}
[x] 2.20 In poor_cli/server.py add async method run_http(self, host: str = "127.0.0.1", port: int = 9876) that creates aiohttp web server with POST /jsonrpc endpoint that accepts JSON-RPC requests and returns JSON-RPC responses, also add WebSocket endpoint /ws for streaming
[x] 2.21 In poor_cli/server.py add function main() that parses args (--stdio, --http, --port), creates server, runs appropriate transport (stdio or http), add if __name__ == "__main__": asyncio.run(main())
[x] 2.22 Update pyproject.toml to add new script entry: poor-cli-server = "poor_cli.server:main" under [project.scripts]
[x] 2.23 Update poor_cli/__init__.py to export PoorCLIServer by adding "from .server import PoorCLIServer" and adding "PoorCLIServer" to __all__ list
[x] 2.24 Create file poor_cli/server_test.py with pytest tests for PoorCLIServer: test_dispatch_initialize, test_dispatch_chat, test_dispatch_inline_complete, test_dispatch_unknown_method, test_json_rpc_message_parsing using mock core

# ============================================================================
# PHASE 3: NEOVIM PLUGIN (nvim-poor-cli/)
# Goal: Create a Lua plugin that provides inline completion and chat in Neovim
# ============================================================================

[x] 3.1 Create directory structure: nvim-poor-cli/lua/poor-cli/, nvim-poor-cli/plugin/, nvim-poor-cli/doc/
[x] 3.2 Create file nvim-poor-cli/lua/poor-cli/config.lua with M = {} table containing defaults: server_cmd = "poor-cli-server --stdio", auto_start = true, ghost_text_hl = "Comment", accept_key = "<Tab>", dismiss_key = "<Esc>", trigger_key = "<C-Space>", chat_key = "<leader>pc", provider = nil (auto-detect), model = nil, api_key_env = nil, and setup(opts) function that merges opts into M
[x] 3.3 Create file nvim-poor-cli/lua/poor-cli/rpc.lua with M = {} implementing JSON-RPC client: M.job_id = nil, M.request_id = 0, M.pending = {} table mapping request_id to callback, M.start() that spawns server_cmd via vim.fn.jobstart with on_stdout/on_stderr/on_exit callbacks, M.stop() that calls vim.fn.jobstop, M.request(method, params, callback) that increments request_id, stores callback in pending, sends JSON-RPC message via vim.fn.chansend, M.notify(method, params) for one-way messages, M.handle_response(data) that parses JSON, looks up callback in pending by id, calls callback(result, error)
[x] 3.4 Create file nvim-poor-cli/lua/poor-cli/inline.lua with M = {} implementing inline ghost text: M.ns_id = vim.api.nvim_create_namespace("poor-cli-inline"), M.current_completion = nil (stores {bufnr, line, col, text}), M.show_ghost_text(text) that clears old extmarks and creates new extmark at cursor with virt_text = {{text, config.ghost_text_hl}} and virt_text_pos = "inline", M.clear_ghost_text() that clears all extmarks in namespace, M.accept() that inserts M.current_completion.text at cursor position and clears ghost text, M.dismiss() that just clears ghost text, M.trigger() that gets cursor position and buffer text, calls rpc.request("poor-cli/inlineComplete", {codeBefore, codeAfter, instruction = "", filePath, language = vim.bo.filetype}, callback that calls M.show_ghost_text)
[x] 3.5 Create file nvim-poor-cli/lua/poor-cli/chat.lua with M = {} implementing chat panel: M.buf = nil, M.win = nil, M.history = {}, M.open() that creates scratch buffer with filetype "markdown" and opens in vertical split, M.close() that closes window, M.toggle() that opens or closes, M.append_message(role, content) that appends formatted message to buffer ("## User\n{content}" or "## Assistant\n{content}"), M.send(message) that appends user message, calls rpc.request("poor-cli/chat", {message = message, contextFiles = M.get_context_files()}, callback that appends assistant response), M.get_context_files() that returns list of open buffer file paths, M.setup_buffer_keymaps() that maps <CR> in insert mode to send current line
[x] 3.6 Create file nvim-poor-cli/lua/poor-cli/commands.lua with M = {} implementing vim commands: M.setup() that creates user commands via vim.api.nvim_create_user_command: "PoorCliStart" -> rpc.start(), "PoorCliStop" -> rpc.stop(), "PoorCliChat" -> chat.toggle(), "PoorCliComplete" -> inline.trigger(), "PoorCliAccept" -> inline.accept(), "PoorCliSwitchProvider" with args -> rpc.request("poor-cli/switchProvider", {provider = args}), "PoorCliStatus" -> print current server status and provider info
[x] 3.7 Create file nvim-poor-cli/lua/poor-cli/keymaps.lua with M = {} implementing default keymaps: M.setup() that sets keymaps via vim.keymap.set: config.trigger_key in insert mode -> inline.trigger(), config.accept_key in insert mode -> inline.accept() if ghost text visible else fallback to original key, config.dismiss_key in insert mode -> inline.dismiss(), config.chat_key in normal mode -> chat.toggle()
[x] 3.8 Create file nvim-poor-cli/lua/poor-cli/autocmds.lua with M = {} implementing autocommands: M.setup() that creates augroup "poor-cli" and autocmds: BufEnter -> send current file context to server, InsertLeave -> clear ghost text, VimLeavePre -> rpc.stop(), optionally CursorHoldI -> auto-trigger completion if enabled in config
[x] 3.9 Create file nvim-poor-cli/lua/poor-cli/init.lua that requires all submodules (config, rpc, inline, chat, commands, keymaps, autocmds) and exports M.setup(opts) function that calls config.setup(opts), commands.setup(), keymaps.setup(), autocmds.setup(), and if config.auto_start then rpc.start() then rpc.request("initialize", {provider = config.provider, model = config.model})
[x] 3.10 Create file nvim-poor-cli/plugin/poor-cli.vim with single line: lua require('poor-cli') to auto-load on Neovim startup (note: setup must be called by user in their config)
[x] 3.11 Create file nvim-poor-cli/doc/poor-cli.txt with Neovim help documentation in vimdoc format covering: introduction, installation (Lazy.nvim, Packer, vim-plug), configuration options table, commands list, keymaps list, API functions, troubleshooting section
[x] 3.12 Create file nvim-poor-cli/README.md with: badges, description, features list (inline completion, chat panel, multi-provider support), installation instructions for Lazy.nvim/Packer/vim-plug, configuration example showing require("poor-cli").setup({}) with all options, usage section with keymaps and commands, screenshots placeholders, requirements (Neovim 0.9+, Python 3.8+, poor-cli installed)
[x] 3.13 In nvim-poor-cli/lua/poor-cli/inline.lua add M.trigger_with_instruction(instruction) that prompts user for instruction via vim.ui.input then triggers completion with that instruction, useful for "generate function that does X" style completions
[x] 3.14 In nvim-poor-cli/lua/poor-cli/inline.lua add M.complete_selection() that gets current visual selection as context, prompts for instruction, replaces selection with AI completion - for "refactor this code to X" style edits
[x] 3.15 In nvim-poor-cli/lua/poor-cli/chat.lua add M.send_with_selection() that gets current visual selection, appends as code block to chat, sends with message asking about the code
[x] 3.16 In nvim-poor-cli/lua/poor-cli/chat.lua add streaming support: modify send() to handle "poor-cli/streamChunk" notifications and append chunks to buffer in real-time
[x] 3.17 Create file nvim-poor-cli/lua/poor-cli/diagnostics.lua with M = {} implementing AI-powered diagnostics: M.analyze_buffer() that sends buffer content to AI asking for issues, M.show_diagnostics() that displays AI suggestions via vim.diagnostic API, M.fix_diagnostic(diagnostic_id) that applies AI-suggested fix
[x] 3.18 Create file nvim-poor-cli/lua/poor-cli/telescope.lua with M = {} implementing telescope.nvim integration if available: M.chat_history() picker to browse/search chat history, M.checkpoints() picker to browse/restore checkpoints, M.providers() picker to switch providers
[x] 3.19 In nvim-poor-cli/lua/poor-cli/commands.lua add "PoorCliExplain" command that gets current line/selection, sends to AI asking for explanation, displays result in floating window
[x] 3.20 In nvim-poor-cli/lua/poor-cli/commands.lua add "PoorCliRefactor" command that gets selection, prompts for refactor instruction, applies AI refactoring via apply_edit RPC
[x] 3.21 In nvim-poor-cli/lua/poor-cli/commands.lua add "PoorCliTest" command that gets current function, asks AI to generate unit tests, inserts tests below function or in test file
[x] 3.22 In nvim-poor-cli/lua/poor-cli/commands.lua add "PoorCliDoc" command that gets current function/class, asks AI to generate docstring, inserts above function
[x] 3.23 Create file nvim-poor-cli/lua/poor-cli/health.lua implementing health check: M.check() that verifies poor-cli-server binary exists, Python version >= 3.8, required Python packages installed, API keys configured, server can start successfully - register with vim.health
[x] 3.24 Update nvim-poor-cli/lua/poor-cli/init.lua to call health check on first setup if requested via config.check_health_on_setup = true

# ============================================================================
# PHASE 4: INTEGRATION & POLISH
# Goal: Make everything work together smoothly
# ============================================================================

[x] 4.1 Create file poor_cli/prompts.py with prompt templates: SYSTEM_INSTRUCTION_INLINE (for code completion), SYSTEM_INSTRUCTION_CHAT (for general chat), SYSTEM_INSTRUCTION_REFACTOR (for code refactoring), SYSTEM_INSTRUCTION_EXPLAIN (for code explanation), SYSTEM_INSTRUCTION_TEST (for test generation), FIM_TEMPLATE with <|fim_prefix|>, <|fim_cursor|>, <|fim_suffix|> markers
[x] 4.2 Update poor_cli/core.py inline_complete() to use prompts from prompts.py and detect if provider supports native FIM (like Codestral) vs needs prompt-based FIM
[x] 4.3 Add file poor_cli/context.py with class ContextManager that handles: gathering relevant files based on imports/references, truncating context to fit token limits, prioritizing recently edited files, caching file contents
[x] 4.4 Update poor_cli/core.py send_message() to use ContextManager for automatically including relevant file context in prompts
[x] 4.5 Create file install_nvim_plugin.sh that copies nvim-poor-cli/ to ~/.local/share/nvim/site/pack/poor-cli/start/nvim-poor-cli/ for manual installation
[x] 4.6 Update README.md in project root to add section about Neovim integration with installation instructions, link to nvim-poor-cli docs
[x] 4.7 Create file nvim-poor-cli/tests/minimal_init.lua with minimal Neovim config for testing the plugin in isolation
[x] 4.8 Create file nvim-poor-cli/tests/test_rpc.lua with plenary.nvim tests for RPC client functionality
[x] 4.9 Create file nvim-poor-cli/tests/test_inline.lua with plenary.nvim tests for inline completion functionality
[x] 4.10 Create GitHub Actions workflow .github/workflows/test-nvim.yml that runs Neovim plugin tests on push
[x] 4.11 Update requirements.txt to add aiohttp>=3.9.0 if not present (needed for HTTP server in phase 2)
[x] 4.12 Create file CHANGELOG.md with entry for v0.5.0 documenting new Neovim integration features

# ============================================================================
# OPTIONAL ENHANCEMENTS
# Nice-to-have features for later
# ============================================================================
